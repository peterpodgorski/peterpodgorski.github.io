<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><title>Separation of What from How - Peter Podgorski</title><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="./../separation-of-what-from-how/"><style>:root{--primary-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--secondary-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"}</style><link rel="stylesheet" href="./../assets/css/fontawesome-all.min.css?v=dbf9d822cefe851ba6f66e1ad57e8987"><link rel="stylesheet" href="./../assets/css/style.css?v=d7345ee9a5567d776f15f161bddf38f7"><noscript><link rel="stylesheet" href="./../assets/css/noscript.css?v=6228c7eee614cd200a2cad8333b439fa"></noscript><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"./../separation-of-what-from-how/"},"headline":"Separation of What from How","datePublished":"2021-03-27T23:34","dateModified":"2022-03-11T23:35","description":"","author":{"@type":"Person","name":"Peter Podgorski"},"publisher":{"@type":"Organization","name":"Peter Podgorski"}}</script><style>#wrapper > .bg {
               background-image: url(./../assets/images/overlay.png), linear-gradient(0deg, rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.1)), url(./../media/website/oip-221-3.jpg);
           }</style></head><body class="is-preload"><div id="wrapper"><header id="header"><a class="logo" href="./../">Peter Podgorski</a></header><nav id="nav"><ul class="links"><li><a href="./../" target="_self">Blog</a></li><li><a href="./../more-about-me-2/" target="_self">About</a></li><li><a href="./../tags/foundations/" target="_self">Foundations</a></li></ul><ul class="icons"><li><a href="https://twitter.com/peter_podgorski" class="icon brands fa-twitter"><span class="label">Twitter</span></a></li><li><a href="https://www.instagram.com/peter.podgorski/" class="icon brands fa-instagram"><span class="label">Instagram</span></a></li><li><a href="https://www.linkedin.com/in/piotrpodgórski/" class="icon brands fa-linkedin"><span class="label">LinkedIn</span></a></li></ul></nav><main id="main"><article class="post"><header class="major"><time datetime="2021-03-27T23:34" class="date">27/03/2021</time><h1>Separation of What from How</h1><p class="post__inner"></p></header><div class="post__inner post__entry"><p>I've been trying to write a post on declarative programming for awhile now, but it always felt a bit too academic for my taste. And a bit too academic to be useful, frankly, because if you're a part of a team, you're not going to go guns blazing into your project screaming "we're switching to Haskell!" Or OCaml.</p><p>No, there's gotta be a way to both get the right gut feeling about what is or isn't declarative, and be able to sneak it into production code without having to ask for permission.</p><p>So I've decided to go over how my <em>style</em> of writing has moved from obnoxiously imperative to more declarative over the years. What helped me get there and how you can do it too.</p><h1 id="the-beginnings">The beginnings</h1><p>It all really started for me with an article by John Carmack in 2012, titled "<a href="https://www.gamasutra.com/view/news/169296/Indepth_Functional_programming_in_C.php">In-Depth: Functional programming in C++</a>" it contained, among others, this gem of a quote:</p><blockquote><p>No matter what language you work in, programming in a functional style provides benefits. You should do it whenever it is convenient, and you should think hard about the decision when it isn't convenient</p></blockquote><p>Reading this, the 24 year old me thought "you have my undivided attention". Or he would've if "Django: Unchained" wasn't almost a year away from the Polish release at that time.</p><p>The article then goes in-depth (duh...) into pure functions and how to do functional-esque programming in C++. I highly encourage you to read it, even if you're not into C++.</p><p>That article doesn't talk directly about declarative programming, but once you start googling for functional, you're destined to find that as well. Which is how I've stumbled upon the most common definition of "declarative programming":</p><blockquote><p>Focusing on the "what" rather than the "how"</p></blockquote><p>But what does that mean, exactly? Well, I can say I didn't fully understand (or feel like I understand...) that until I've listened to the numerous talks by Kevlin Henney. Once you're finished here, grab some popcorn and run <a href="https://www.youtube.com/playlist?list=PL6wxfKvkNqRugfIiKKgRXa_0wKIQW_ZEH">this playlist</a>.</p><p>I think that the best way to start really understanding it is to look at the <em>single simplest change</em> you can make to your code, and the way you write it, to bring it closer to the declarative side of things, and thus to arguably improve it.</p><h1 id="disclaimer">Disclaimer</h1><p>I'll be describing this through the prism of object oriented programming, which Wikipedia puts under the "imperative" umbrella. That makes sense <em>historically</em> but not necessarily logically.</p><p>My advice is... don't think about this too much. I'll explain the distinction between declarative and imperative in a sec, but what's important is that OOP can be entirely imperative or entirely declarative or anything in between.</p><p>I'd also argue that declarative and imperative ends of the spectrum could just as well be labeled "good" and "bad", but I know not everyone agrees. And that's fine, as long as I don't have to work on their code 🤣</p><h1 id="show-me-the-code">Show me the code</h1><p>Let's look at the simplest possible example, capturing only the essence of the distinction, as well as how it's inescapably intertwined with separation of concerns and encapsulation.</p><p>This code is on the imperative side:</p><pre><code class="lang-python">def download_new_users(self) -&gt; List[User]:</code></pre><p>While this one is more declarative:</p><pre><code class="lang-python">def new_users(self) -&gt; Users:</code></pre><p>There are a couple of differences here. Most notably, the first example contains a prefix "download", which tells you exactly how it obtains the users - it downloads them, possibly from an external service.</p><p>Is this <em>really</em> something the code using that method should care about? I'd argue not. This is an example of an implementation detail leaking outside encapsulation, even if "just" in the name. If you come up with a better (faster, more reliable, etc.) way of obtaining a list of new users, what are you going to do? If you leave it like this, it's going to become misleading. If not, your only choice is to change that name in the entire codebase. Now, I realise that your IDE will do it for you but still... <em>yuck!</em></p><p>Even worse, that method returns a <strong>list</strong> of User objects. It's better than a list of dictionaries, but it is yet another implementation detail leaking outside. Moreover, it creates <em>adhesion</em> between that method and... literally everything else using it.</p><p>Kevlin Henney often says that returning basic types from functions is the ultimate destruction of encapsulation. For instance, if I wanted to further filter that list of users, I'd have to write something like this:</p><pre><code class="lang-python">kents = [u for u in download_new_users() if u.first_name == "Kent"]</code></pre><p>And I would probably be tempted to do it inline, because hey... I need it once.</p><p>Instead of doing this:</p><pre><code class="lang-python">kents = new_users().named("Kent")</code></pre><p>Now... you may think it makes no difference, because it's highly plausible the actual implementation will look something like this:</p><pre><code class="lang-python">@dataclass
class Users:
    _users: Iterable[User]

    def named(self, first_name) -&gt; Users:
        return Users(
            [u for u in self._users if u.first_name == first_name]
        )</code></pre><p>So there's no real difference for the computer! To which I say:</p><blockquote><p>Any fool can write code that a computer can understand. Good programmers write code that humans can understand. — Martin Fowler</p></blockquote><p><code>new_users().named("Kent")</code> is more immediately understandable to a human than the alternative, and it's a hill I'm willing to die on. You could show this piece of code to a complete layman and they'd tell you immediately what this code does because it says it in plain english (extra syntax notwithstanding). Try doing that with a list comprehension.</p><p>But there's more to it. <strong>It's not only more declarative, it's also better encapsulated, which usually goes hand in hand</strong>. Which means I can change that implementation... For instance, to one that uses generators or lazily builds a database query (similar to an ORM). And, most importantly, that would not affect the rest of the code in any way. It would be entirely transparent. My code's behaviour becomes implementation-agnostic!</p><p>I know what I just wrote may not be groundbreaking to you... But, judging by all the code bases I've seen within the last decade or so, it may very well be to many.</p><h1 id="domain-specific-languages">Domain Specific Languages</h1><p>One of the coolest uses (if not consequences) of writing in a declarative way is domain specific languages, or DSLs. What is that? The usual example is SQL:</p><pre><code class="lang-sql">SELECT * FROM users WHERE name="Kent"</code></pre><p>It's fairly obvious that this language is <em>domain-specific</em>. You're not going to write a generic program with it, you're just going to select "Kents" from the "users". Do you care exactly <em>how</em> the database will do it? No. You may give it hints, you may ask it to explain, but all in all it's not a <code>for</code> with a nested <code>if</code>.</p><p>The thing is, our example of <code>new_users().named("Kent")</code> can also be considered a DSL. The best thing about DSLs? Done right, and coupled with overall domain-driven design, they basically end up looking intelligible for domain experts. It doesn't mean they'll be able to modify the logic, but they may be able to read it, or at least to understand you reading it verbatim (removing just the syntax, which may be confusing to some).</p><p>The best thing is, done right a program expressed in a DSL will be <em>dead easy</em> to modify. Not just because it'll be easy to talk about it with domain experts, but because the domain will probably change evolutionarily rather than revolutionarily. If you start with a language that follows the problem domain closely, there's a higher chance it'll be able to keep doing that as the domain evolves.</p><h1 id="naming">Naming</h1><p>All in all, <strong>everything</strong> comes down to naming. <em>Code is made of code.</em> It's a shapeless, isotropic blob, and the only thing breaking the homogeneity of your program is how you name things <strong>and</strong> groups of things. And possibly <em>whether</em> you name them.</p><p>In fact, one of the single best metrics I can think of when it comes to code quality is the ratio of things named to things unnamed. What do I mean by that?</p><p>Well, look at this <a href="https://github.com/hchasestevens/astpath/blob/master/astpath/asts.py#L30">piece of code</a> for the (insanely great, btw) <code>astpath</code> tool for Python. This file contains <strong>81 </strong>meaningful lines of code (disregarding imports) and yet merely <strong>3</strong> functions. In other words, only 3 "building blocks" of that code are named.</p><p>Sure, there are variables and imported classes, but unless you really dig into e.g. the block between lines 61 and 80 there's <em>no way in hell</em> you'll understand what it's supposedly doing. You can, however, very clearly see <em>how</em> it does whatever it does. It utilises etree, there's a conditional statement and a for loop with some conditionals thrown in for good measure.</p><p>Looking at this code at a glance I can roughly tell how much work the interpreter and the CPU are going to have running it <em>before</em> I understand what it even does. What jumps out at me are the language constructs, not the intent of that particular block.</p><h1 id="uncertainty-principle">Uncertainty Principle</h1><p>And that's the key distinction between imperative and declarative programming. I like to call it the "programming uncertainty principle". The more exposed the implementation (imperative) is, the less obvious the intent (declarative) and vice versa.</p><p>The fun part is that an API which looks very declarative from the outside, may very well be extremely imperative on the inside. In fact, sometimes it will have to be for performance reasons, because imperative code will, in many cases, be quicker than declarative code.</p><h1 id="the-paradox-of-optimisation">The paradox of optimisation</h1><p><strong>That said</strong> starting at the imperative end of the spectrum for the sake of performance is usually a sign of premature optimisation. I've seen people avoid function calls in Python, due to them being relatively expensive in the absence of inline, leading to 1000-line long functions, impossible to read, comprehend, modify, and (amusingly, yet consequently) impossible to optimise.</p><p>This is the paradox - while imperative code may very well be quicker, it's still better to start with declarative code, find (through profiling) the exact areas that are slow, and re-implement <em>them</em> in a more imperative style (or in a different language) behind a declarative facade. Doing it the other way around... may prove impossible, especially given that highly imperative code tends also to be less testable.</p><h1 id="how-to-start-">How to start?</h1><p>How to start writing more declarative code? First focus on naming. Force yourself to avoid prefixes, including ones like "get" and "set". This <em>will</em> be hard at first.</p><p>Then, always think twice before returning a basic type from a function. This <em>will</em> feel like needless extra work at first. Once you're comfortable with that, you may stop using basic types for your fields. For instance:</p><pre><code class="lang-python">@dataclass
class CreditCard:
    number: str</code></pre><p>becomes:</p><pre><code class="lang-python">@dataclass
class CreditCard:
    number: CCNumber</code></pre><p>This <em>will</em> feel like needless extra work at first, before you realise it allows you to <a href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/">parse, not validate</a>. From there, nothing will be the same.</p><p>Finally, do TDD. And yes, that's the <em>last</em> step. Because while I believe TDD will greatly support you in those efforts, going into it without the right mindset you will likely end up testing implementation details. Which has the potential of scaring you off TDD for good...</p><h1 id="test-driven-declarative">Test-driven declarative</h1><p>Thinking back, I'm fairly sure it was the pursue of declarative programming that brought me to TDD in the first place (along with laziness). Test-driven development is, by its very nature, declarative.</p><p>You state the circumstances, you state the end result, and you put an empty shell of a behaviour subroutine in between. I emphasise the "behaviour" part here, because you should be focusing on what the code <em>does</em> rather than what it <em>is</em>.</p><blockquote><p>I’m sorry that I long ago coined the term "objects" for this topic because it gets many people to focus on the lesser idea.</p></blockquote><blockquote><p>The big idea is "messaging."…The key in making great and growable systems is much more to design how its modules communicate rather than what their internal properties and behaviors should be. — Alan Kay</p></blockquote><p>Once you have that, you fill that shell with implementation, which is completely disjointed from the test. Then you refactor, which could mean just moving things around, but just as well changing the implementation <em>drastically</em>, while keeping the API unchanged and the outside world unaffected. And then you may also have multiple implementations for different circumstances.</p><h1 id="tdd-as-an-early-warning-system">TDD as an early warning system</h1><p>Eventually you may find your TDD cycle slowing down. Test preparation becomes more tedious, refactoring becomes harder, or implementing one thing requires touching more than one place.</p><p>More often than not, this indicates you have a leaking implementation detail somewhere. Which usually means there's some area of your system which is not declarative <em>enough</em>. That's where you should stop wrestling with implementing your feature and fix that problem.</p><blockquote><p>for each desired change, make the change easy (warning: this may be hard), then make the easy change — <a href="https://twitter.com/KentBeck/status/250733358307500032">Kent Beck</a></p></blockquote><h1 id="the-point-of-software-is-to-change">The point of software is to change</h1><p>Programmers often think their job is to make a computer do something, but that's not true.</p><p>We've been able to do that long before programming was even invented. Dedicated, non-programmable hardware is more than capable of doing a single thing perfectly forever, and it would probably do it <em>far</em> more efficiently.</p><p>The purpose of programming and of a programmer is to make a computer do one thing today, another tomorrow, and yet another the day after. Programming in a declarative way aids separation of concerns, which is great at helping you achieve that at a steady, sustainable pace.</p></div><footer class="post__inner post__footer"><div class="post__share-tag-container"><div class="post__share"><button class="post__share-button js-post__share-button icon" aria-label="Share button"><i class="fas fa-share-alt"></i></button><div class="post__share-popup js-post__share-popup"><a href="https://twitter.com/share?url=%23PUBLII_RELATIVE_URL_BASE%23%2Fseparation-of-what-from-how%2F&amp;via=peter_podgorski&amp;text=Separation%20of%20What%20from%20How" class="js-share icon brands fa-twitter" rel="nofollow noopener noreferrer"><span class="label">Twitter</span> </a><a href="https://www.linkedin.com/sharing/share-offsite/?url=%23PUBLII_RELATIVE_URL_BASE%23%2Fseparation-of-what-from-how%2F" class="js-share icon brands fa-linkedin" rel="nofollow noopener noreferrer"><span class="label">LinkedIn</span></a></div></div></div></footer></article></main><footer id="copyright"><p>“When you program, you have to think about how someone will read your code, not just how a computer will interpret it.”<br>— Kent Beck</p></footer></div><script src="./../assets/js/jquery.min.js?v=7c14a783dfeb3d238ccd3edd840d82ee"></script><script src="./../assets/js/jquery.scrollex.min.js?v=f89065e3d988006af9791b44561d7c90"></script><script src="./../assets/js/jquery.scrolly.min.js?v=1ed5a78bde1476875a40f6b9ff44fc14"></script><script src="./../assets/js/browser.min.js?v=c07298dd19048a8a69ad97e754dfe8d0"></script><script src="./../assets/js/breakpoints.min.js?v=81a479eb099e3b187613943b085923b8"></script><script src="./../assets/js/util.min.js?v=4201a626f8c9b614a663b3a1d7d82615"></script><script src="./../assets/js/main.min.js?v=149e72e3ae18744a477b480b19e0c6da"></script></body></html>