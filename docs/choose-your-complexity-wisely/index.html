<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><title>Choose your complexity wisely - Peter Podgorski</title><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="./../choose-your-complexity-wisely/"><style>:root{--primary-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--secondary-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"}</style><link rel="stylesheet" href="./../assets/css/fontawesome-all.min.css?v=dbf9d822cefe851ba6f66e1ad57e8987"><link rel="stylesheet" href="./../assets/css/style.css?v=ac3f407b0c1f1aeda11a54119a45cb9c"><noscript><link rel="stylesheet" href="./../assets/css/noscript.css?v=6228c7eee614cd200a2cad8333b439fa"></noscript><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"./../choose-your-complexity-wisely/"},"headline":"Choose your complexity wisely","datePublished":"2021-09-25T23:37","dateModified":"2022-03-11T23:38","description":"","author":{"@type":"Person","name":"Peter Podgorski"},"publisher":{"@type":"Organization","name":"Peter Podgorski"}}</script><style>#wrapper > .bg {
               background-image: url(./../assets/images/overlay.png), linear-gradient(0deg, rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.1)), url(./../media/website/oip-221-3.jpg);
           }</style></head><body class="is-preload"><div id="wrapper"><header id="header"><a class="logo" href="./../">Peter Podgorski</a></header><nav id="nav"><ul class="links"><li><a href="./../" target="_self">Blog</a></li><li><a href="./../more-about-me-2/" target="_self">About</a></li><li><a href="./../tags/foundations/" target="_self">Foundations</a></li></ul><ul class="icons"><li><a href="https://twitter.com/peter_podgorski" class="icon brands fa-twitter"><span class="label">Twitter</span></a></li><li><a href="https://www.instagram.com/peter.podgorski/" class="icon brands fa-instagram"><span class="label">Instagram</span></a></li><li><a href="https://www.linkedin.com/in/piotrpodgórski/" class="icon brands fa-linkedin"><span class="label">LinkedIn</span></a></li></ul></nav><main id="main"><article class="post"><header class="major"><time datetime="2021-09-25T23:37" class="date">25/09/2021</time><h1>Choose your complexity wisely</h1><p class="post__inner"></p></header><div class="post__inner post__entry"><p>There's not a more loaded, dangerous, and ambiguous term in programming than "simple". KISS (<em>keep it simple, stupid</em>) is probably the least helpful advice possible, especially for novice programmers. The only other competitor here is DRY.</p><p>What does "simple" even mean? Is a Django MVC-esque application simpler than, say, a full blown DDD-ed, event sourced, hexagonal service? Is an application simpler when it has a framework instead of an architecture?</p><p>In some ways, yes - it's easier to understand and get around <em>technically</em>, because proficiency in the framework is sufficient and proficiency in the domain is not required. At the same time, try modifying a system of this sort — in any but the least demanding of domains — after a little bit of time... Good luck with that.</p><p>The usual understanding is that simple is about less parts, but that’s not true. Welding wheels to a car's axles removes parts (lug nuts), but it arguably makes the car <em>harder to change</em>. It also makes the car harder to understand, because the boundary between two very distinct parts — an axle and a wheel — gets fuzzy. It becomes more challenging to understand what a car is <em>made of</em>.</p><p>Just to be clear, this is not an attack on Django or MVC. <strong>It's just that "simple" is context dependent, and in more than one way. What we mean by it depends on the domain under implementation, as well as the knowledge and skills we have.</strong></p><h2>With great advice comes great responsibility</h2><p><em>Simple</em> is defined as "easily understood or done; presenting no difficulty, without much decoration or ornamentation". A related word, <em>simplistic</em>, by contrast means "treating complex issues and problems as if they were much simpler than they really are". And while the difference in these definitions is striking, the boundary between the two is not at all clear cut or obvious...</p><p>At least not at first. One day you just notice that your system is so fragile that touching it in any way whatsoever resembles a game of Mikado...</p><p>The advice to “keep things simple”, “build only what you need”, and “try not to predict the future” flow from the experienced to the novice (obviously...), and the experienced don't always take the time to explain what they mean. Or even manage to remember the novice might not be equipped to understand the message as intended.</p><p>The solution? <strong>Stop pretending any software system with a TTL longer than a week can ever be described as "simple"</strong>. Understand that <em>simplistic</em> leads to <em>complicated</em>, and that people will naturally gravitate towards simplistic when told to make something simple.</p><p>They will disregard, or lack the experience to appreciate, the complexity and design involved, and will just assume that if they don't “over-engineer” everything will be fine. It probably won’t.</p><p>It's a similar story with up-front design. People were told to limit (or scrap) up-front design, <strong>and they listened</strong>. Unfortunately, what was lost in translation was that it never meant <em>don't design</em>. It means "accept that programming is a design activity and design as you code, using the knowledge you're gaining".</p><p><strong>The unintended consequence are systems with no design, which basically look like a steaming pile of entropy.</strong></p><h2>The hidden assumption</h2><p>It seems to be implicitly assumed that it will be understood that the simplicity of design stems from the skilled usage of paradigms and careful selection of patterns, driven by design techniques named with acronyms ending with *DD - DDD, TDD, BDD, ATDD.</p><p>Reality, however, is different. Sounds bites, like KISS and DRY, are picked up by people who then <strong>assume simplicity is simple to achieve and try to achieve it in simplistic ways</strong> with none of the tools initially assumed. And that's how systems with noting but accidental complexity happen.</p><p>I say these things because I see them happen all the time, and because I've fallen victim to these misconceptions myself. I got so hung up on thinking that design is wasteful, that simplicity is all that matters, and that simplicity is easily achieved, that I've been heard saying that "a monkey could do programming, as long as it had access to stack overflow". It was a terribly stupid thing to say, but I used to think that.</p><p>What’s worse, the people I used to work with, who then had multiples of my years of experience, thought that to! And the software they wrote made it painfully obvious we were all wrong. What I'm trying to say is that people can be easily mislead, even if the message's intent is good. And then they go on to radiate the misconceptions <em>until the whole continent is dead. </em>To be abundantly clear — I don’t blame anyone for having been an idiot, but I do think that there’s room for improvement in communication.</p><p>So... what are the solutions? What I started to say instead of "keep it simple" is <strong>"choose your complexity wisely"</strong>. The reason I like this way of putting it is because it brings two truths to the front:</p><ol data-rte-list="default"><li><p>Complexity is inevitable and unavoidable, but you can choose your fights</p></li><li><p>It takes wisdom to make the right call, and you <em>will</em> still be wrong</p></li></ol><p>The most important emphasis, to me, is that managing complexity requires knowledge. It is, itself, a complex subject and one should not be fooled into thinking it's easy.</p></div><footer class="post__inner post__footer"><div class="post__share-tag-container"><div class="post__share"><button class="post__share-button js-post__share-button icon" aria-label="Share button"><i class="fas fa-share-alt"></i></button><div class="post__share-popup js-post__share-popup"><a href="https://twitter.com/share?url=%23PUBLII_RELATIVE_URL_BASE%23%2Fchoose-your-complexity-wisely%2F&amp;via=peter_podgorski&amp;text=Choose%20your%20complexity%20wisely" class="js-share icon brands fa-twitter" rel="nofollow noopener noreferrer"><span class="label">Twitter</span> </a><a href="https://www.linkedin.com/sharing/share-offsite/?url=%23PUBLII_RELATIVE_URL_BASE%23%2Fchoose-your-complexity-wisely%2F" class="js-share icon brands fa-linkedin" rel="nofollow noopener noreferrer"><span class="label">LinkedIn</span></a></div></div></div></footer></article></main><footer id="copyright"><p>“When you program, you have to think about how someone will read your code, not just how a computer will interpret it.”<br>— Kent Beck</p></footer></div><script src="./../assets/js/jquery.min.js?v=7c14a783dfeb3d238ccd3edd840d82ee"></script><script src="./../assets/js/jquery.scrollex.min.js?v=f89065e3d988006af9791b44561d7c90"></script><script src="./../assets/js/jquery.scrolly.min.js?v=1ed5a78bde1476875a40f6b9ff44fc14"></script><script src="./../assets/js/browser.min.js?v=c07298dd19048a8a69ad97e754dfe8d0"></script><script src="./../assets/js/breakpoints.min.js?v=81a479eb099e3b187613943b085923b8"></script><script src="./../assets/js/util.min.js?v=4201a626f8c9b614a663b3a1d7d82615"></script><script src="./../assets/js/main.min.js?v=149e72e3ae18744a477b480b19e0c6da"></script></body></html>