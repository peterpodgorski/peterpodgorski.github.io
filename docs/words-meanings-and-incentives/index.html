<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><title>Words, meanings, and incentives - Peter Podgorski</title><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="./../words-meanings-and-incentives/"><style>:root{--primary-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--secondary-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"}</style><link rel="stylesheet" href="./../assets/css/fontawesome-all.min.css?v=dbf9d822cefe851ba6f66e1ad57e8987"><link rel="stylesheet" href="./../assets/css/style.css?v=d7345ee9a5567d776f15f161bddf38f7"><noscript><link rel="stylesheet" href="./../assets/css/noscript.css?v=6228c7eee614cd200a2cad8333b439fa"></noscript><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"./../words-meanings-and-incentives/"},"headline":"Words, meanings, and incentives","datePublished":"2021-11-07T23:38","dateModified":"2022-03-11T23:41","description":"","author":{"@type":"Person","name":"Peter Podgorski"},"publisher":{"@type":"Organization","name":"Peter Podgorski"}}</script><style>#wrapper > .bg {
               background-image: url(./../assets/images/overlay.png), linear-gradient(0deg, rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.1)), url(./../media/website/oip-221-3.jpg);
           }</style></head><body class="is-preload"><div id="wrapper"><header id="header"><a class="logo" href="./../">Peter Podgorski</a></header><nav id="nav"><ul class="links"><li><a href="./../" target="_self">Blog</a></li><li><a href="./../more-about-me-2/" target="_self">About</a></li><li><a href="./../tags/foundations/" target="_self">Foundations</a></li></ul><ul class="icons"><li><a href="https://twitter.com/peter_podgorski" class="icon brands fa-twitter"><span class="label">Twitter</span></a></li><li><a href="https://www.instagram.com/peter.podgorski/" class="icon brands fa-instagram"><span class="label">Instagram</span></a></li><li><a href="https://www.linkedin.com/in/piotrpodgórski/" class="icon brands fa-linkedin"><span class="label">LinkedIn</span></a></li></ul></nav><main id="main"><article class="post"><header class="major"><time datetime="2021-11-07T23:38" class="date">07/11/2021</time><h1>Words, meanings, and incentives</h1><p class="post__inner"></p></header><div class="post__inner post__entry"><p>Words. They're kind of important. We use them to convey meaning, to communicate with each other. One of the most important steps in building a computer system with a remote chance of standing the test of (change over) time is establishing a ubiquitous language - one that <em>everyone</em> working on the product agrees on. Language and words should be of utmost importance especially to programmers, because our trade is precisely building stuff out of words. Which is why it's so baffling how <em>bad</em> with language we typically are. And I'm not even talking about sloppy, lazy naming like <em>data</em> or <em>utils</em>. I'm talking about much more high level stuff... And there's no better illustration of it than...</p><h2>CI/CD</h2><p>Now... I know that language evolves, I get that. Words lose and gain meanings all the time. Incorrect usages of words become accepted over the time. And while it literally pains me that "literally" can now be legitimately used figuratively, I try to accept that. But again... as people who build stuff out of words, we should know better. And more importantly, we should know that some of those misnomers and misconceptions are actively harmful. CI/CD is one of those.</p><p>There's no such thing as "CI/CD". What people almost universally mean when they say "we have CI/CD" is a <strong>pipeline</strong>. And having a pipeline in place <strong>does not</strong> imply either continuous integration or continuous delivery, so neither should the term we use to name it. See, I wouldn't have a problem with it if they said "we have Steve", because while it also makes no sense, Steve doesn't imply CI - CI/CD does.</p><p>Continuous Integration, or CI, is the act of keeping your code integrated continuously. Which means there are no divergent changes sitting in the repo and evolving separately for prolonged periods of time.</p><p>People often quote Kent Beck and Dave Farley about how CI is "merging once a day", but that's a misunderstanding. CI is merging <em>at the very least</em> once a day. It's the bare minimum to even qualify, not the universal speed limit. It's as if you were a race driver, qualified with the slowest time and then just called it a day, because you've qualified - no!</p><p>What is the end goal? When can you truly say that you've committed to, and are actually practicing, <em>continuous</em>integration in a way that creates the right incentives? Well...</p><blockquote><p>Continuous is more often than you think — Mike Roberts</p></blockquote><p>At this stage and in the age of Git, the end goal is <strong>not branching</strong>. Literally, in the non-figurative sense.</p><figure class="post__video"><iframe width="560" height="314" src="https://www.youtube.com/embed/lXQEi1O5IOI" allowfullscreen="allowfullscreen" data-mce-fragment="1"></iframe></figure><figure class="post__video"><iframe width="560" height="314" src="https://www.youtube.com/embed/_w6TwnLCFwA" allowfullscreen="allowfullscreen" data-mce-fragment="1"></iframe></figure><p>You have a single branch. Call it trunk, main, whatever — the point is there's one. And everyone on the team commits and pushes to that branch, without going through feature branches. That's the closest you can get to "continuous" with Git without mob programming (1 commit per team, instead of 1 commit per person). I'm looking very closely at <a href="https://getsturdy.com/">Sturdy</a> in this space, as it could make a huge difference, and I suggest you do that as well.</p><p>So CI is about <em>continuous integration</em>... as the name implies. What about CD?</p><p><strong>Continuous Delivery, or CD, is the practice of keeping your code operational at all times</strong>. Not broken. Without regression. It may have unknown defects (although, contrary to popular belief, <em>not all code has bugs</em>), but it can't have <em>known</em> ones — these are to be eliminated ASAP, and they always take priority over everything else. If a test fails, you fix the problem indicated by that failure before moving on.</p><p>Because CD is built on top of CI, the codebase will contain incomplete features. However, the whole codebase, including these half-baked bits, is always in a deployable state — it's always delivered. The ultimate goal here is to be able to hit "deploy" at an arbitrary moment and then close your laptop and go into the woods for a month without a worry in the world. That's what you're striving for with CD. And when I say "arbitrary" I mean it — it's not continuous delivery if you can't deploy <em>right now.</em></p><figure class="post__video"><iframe width="560" height="314" src="https://www.youtube.com/embed/po712VIZZ7M" allowfullscreen="allowfullscreen" data-mce-fragment="1"></iframe></figure><p>You may have noticed something... I never said anything about pipelines, let alone specific tools, like Travis or Jenkins. Why? Because CI and CD are <em>practices</em> not <em>tools</em>. They're something you do, not something you use. They're mindsets of building quality into every stage of the software development process.</p><p>Pipelines, on the other hand, are tools to achieve that. However, just like the Andon Cord in GM factories, they make no difference without the underlying philosophy they're supposed to support.</p><p>CI and CD are well known to be good practices in the industry, which is why almost all teams around the world claim to adhere to them. But then you look at how they work and you see a very different picture:</p><ol data-rte-list="default"><li><p>There are feature branches</p></li><li><p>These feature branches live for days and weeks and months</p></li><li><p>They're huge, these feature branches</p></li><li><p>Merging is a Sisyphean task</p></li><li><p>There's a pipeline, but there are barely any tests</p></li><li><p>The few tests that there are are red most of the time, and nobody cares</p></li><li><p>Going through the pipeline takes way upwards of 5 minutes</p></li><li><p>Deployments are coupled with releases</p></li><li><p>Deployments are thus eventful, instead of mundane</p></li><li><p>The act of deploying is ceremonious and everyone's afraid of its repercussions. They can't deploy <em>right now</em>.</p></li></ol><p>These teams call their pipeline "CI/CD", not realising that all they have is, in fact, a pipeline... without CI or CD. And without the benefits of either.</p><h2>Trunk-based development</h2><p>This one's actually funny, because it's one of those terms that pop into existence to fill the void left by another term after it's has been deprived of meaning, and end up not only doing a worse job conveying the point but also watering down the original concept.</p><p>TBD came into existence, I believe, because CI has lost its original meaning and started to mean "pipeline". Now... TBD is not a bad name per se, but Continuous Integration is better precisely because it contains the word "continuous". I just wish people paid more attention to that.</p><p>Worse, however, TBD allows for the idea of "short-lived feature branches", which is the watering down I've mentioned before. Feature branches are <em>wrong</em>. It doesn't matter if they're long or short lived, they introduce the wrong incentives!</p><p>The incentives created by a process is an often overlooked problem, which greatly impacts the results you're getting from that process.</p><p>Feature branches are, in most teams, tightly coupled with the idea of gatekeeping code review. Meaning, before a change is integrated into main it has to be examined by another human being or two. That human leaves a couple of useless comments about code formatting or initiates pointless discussions around the code to comment ratio, plus perhaps leaves a single useful comment about naming and then we pat each other on the back and consider quality assurance done. But it isn't... It's theatre.</p><p>Code review itself is a great practice — periodic visual inspection is a great idea! And decoupling that from making changes is good, as long as you do it with a clear head and a dedicated focus time. Gatekeeping code review, however, is... dangerous. <strong>It's dangerous because it fools us into thinking we're doing a good job and thus de-incentivises building quality into writing code</strong> with these dramatic new ideas from the late 90s:</p><ul data-rte-list="default"><li><p>Ensamble (pair, group) programming</p></li><li><p>Continuous Integration</p></li><li><p>Continuous Delivery</p></li><li><p>Test Driven Development</p></li><li><p>Acceptance Test Driven Development</p></li><li><p>or, you know, <strong>training people</strong></p></li></ul><p>As well as removing the opportunity for pointless flamewars by using automated code formatters, linters, etc.</p><p>The whole point of Continuous Integration is to build an environment in which people can commit directly into trunk or main and be certain (to the level allowed by the current state of art and tools) that if they break something, the checks in place will let them know. As well as limiting the chance that they'll break something in the first place.</p><p>We're deliberately setting out to do something that, intuitively, feels risky because such approach creates an incentive to reduce those risks. And the reason we're doing it is because we realise those risks are there and we recognise that creating an illusion of having dealt with them <em>increases</em> the danger.</p><p>Which brings us to the point about trust and whether all team members are equally trust-worthy. Which is often brought up when I suggest continuous integration.</p><p>I've been the senior developer gatekeeping junior devs' code from entering main until it's magically passed the bar of adequacy. And I say magically because all they had to work on were my comments, which (over time...) typically started containing more and more actual code... Because, you know, it's quicker that way.</p><p>I've eventually learned that, in cases like these, pair programming is simply more efficient — both at getting shit done, and teaching. Feature branches, even the short lived ones, augmented with pull requests de-incentivise pair programming in favour of what's basically asynchronous "email exchange" within GitHub.</p><p>So there you go... Martin Fowler famously said "if it hurts, do it more often". I'd like to add: if it feels risky, confront it and reduce the risks with training and automation, instead of sweeping them under a rug. And there's no worse form of sweeping under a rug than using terms that meant a deliberate effort to mean mindlessly plugging in a tool, and then patting yourself on the back for doing a good job.</p></div><footer class="post__inner post__footer"><div class="post__share-tag-container"><div class="post__share"><button class="post__share-button js-post__share-button icon" aria-label="Share button"><i class="fas fa-share-alt"></i></button><div class="post__share-popup js-post__share-popup"><a href="https://twitter.com/share?url=%23PUBLII_RELATIVE_URL_BASE%23%2Fwords-meanings-and-incentives%2F&amp;via=peter_podgorski&amp;text=Words%2C%20meanings%2C%20and%20incentives" class="js-share icon brands fa-twitter" rel="nofollow noopener noreferrer"><span class="label">Twitter</span> </a><a href="https://www.linkedin.com/sharing/share-offsite/?url=%23PUBLII_RELATIVE_URL_BASE%23%2Fwords-meanings-and-incentives%2F" class="js-share icon brands fa-linkedin" rel="nofollow noopener noreferrer"><span class="label">LinkedIn</span></a></div></div></div></footer></article></main><footer id="copyright"><p>“When you program, you have to think about how someone will read your code, not just how a computer will interpret it.”<br>— Kent Beck</p></footer></div><script src="./../assets/js/jquery.min.js?v=7c14a783dfeb3d238ccd3edd840d82ee"></script><script src="./../assets/js/jquery.scrollex.min.js?v=f89065e3d988006af9791b44561d7c90"></script><script src="./../assets/js/jquery.scrolly.min.js?v=1ed5a78bde1476875a40f6b9ff44fc14"></script><script src="./../assets/js/browser.min.js?v=c07298dd19048a8a69ad97e754dfe8d0"></script><script src="./../assets/js/breakpoints.min.js?v=81a479eb099e3b187613943b085923b8"></script><script src="./../assets/js/util.min.js?v=4201a626f8c9b614a663b3a1d7d82615"></script><script src="./../assets/js/main.min.js?v=149e72e3ae18744a477b480b19e0c6da"></script></body></html>