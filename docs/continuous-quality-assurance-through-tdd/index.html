<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><title>Continuous quality assurance through TDD - Peter Podgorski</title><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="./../continuous-quality-assurance-through-tdd/"><style>:root{--primary-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--secondary-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"}</style><link rel="stylesheet" href="./../assets/css/fontawesome-all.min.css?v=dbf9d822cefe851ba6f66e1ad57e8987"><link rel="stylesheet" href="./../assets/css/style.css?v=ac3f407b0c1f1aeda11a54119a45cb9c"><noscript><link rel="stylesheet" href="./../assets/css/noscript.css?v=6228c7eee614cd200a2cad8333b439fa"></noscript><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"./../continuous-quality-assurance-through-tdd/"},"headline":"Continuous quality assurance through TDD","datePublished":"2021-01-30T23:26","dateModified":"2022-03-11T23:34","description":"","author":{"@type":"Person","name":"Peter Podgorski"},"publisher":{"@type":"Organization","name":"Peter Podgorski"}}</script><style>#wrapper > .bg {
               background-image: url(./../assets/images/overlay.png), linear-gradient(0deg, rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.1)), url(./../media/website/oip-221-3.jpg);
           }</style></head><body class="is-preload"><div id="wrapper"><header id="header"><a class="logo" href="./../">Peter Podgorski</a></header><nav id="nav"><ul class="links"><li><a href="./../" target="_self">Blog</a></li><li><a href="./../more-about-me-2/" target="_self">About</a></li><li><a href="./../tags/foundations/" target="_self">Foundations</a></li></ul><ul class="icons"><li><a href="https://twitter.com/peter_podgorski" class="icon brands fa-twitter"><span class="label">Twitter</span></a></li><li><a href="https://www.instagram.com/peter.podgorski/" class="icon brands fa-instagram"><span class="label">Instagram</span></a></li><li><a href="https://www.linkedin.com/in/piotrpodg√≥rski/" class="icon brands fa-linkedin"><span class="label">LinkedIn</span></a></li></ul></nav><main id="main"><article class="post"><header class="major"><time datetime="2021-01-30T23:26" class="date">30/01/2021</time><h1>Continuous quality assurance through TDD</h1><p class="post__inner"></p></header><div class="post__inner post__entry"><p>A recent conversation reminded me that there is a misconception that TDD slows you down. At the very least in the short term, because you have to write more stuff. This claim is as false as it is perfectly intuitive and logically sound at the first glance.</p><p>Worse, all of these tests are perceived as a wasted effort, because in a highly dynamic, fast moving project they may never even have a chance of preventing regression, and that's what we write tests for, isn't it? Well, not in TDD.</p><h1>A design strategy</h1><blockquote><p>Test-driven development is meant to eliminate fear in application development</p></blockquote><p>The "test" part in TDD is less relevant than the "driven development" part. It's about having a force guiding your code towards quality, rather than catching regressions ex post facto. Frankly, I'm so used to thinking of TDD as a design strategy that I sometimes call it "test driven design" instead of "test driven development" ü§∑‚Äç‚ôÇÔ∏è.</p><p>It's a declarative approach to programming. It forces you to first think of "what" and "why" before you can move on to "how". It helps you¬†<a href="https://en.wikipedia.org/wiki/Kaizen">take small, well understood steps</a> and supports "<a href="https://vimeo.com/108441214">coding for deletion</a>". You write tiny little bits of code, each of which serves a single, well-defined purpose. Solves a problem stated without conjunctions. You get them to¬†<em>fully operational state very quickly,</em>¬†and can discard or replace them with little effort and negligible sunken cost. The test is there to help you keep your code small and working continuously, so you can learn about your misunderstandings quicker.</p><p>Which is really cool, if you think about it, because it saves you from writing needless code. If you expand (and you should) into ATDD, you get even more of that. It means you get more informed decisions, more feedback from valuable experiments, and less blind alleys of "what was I thinking?".</p><p>And if you actually unintentionally change something in the process, possibly introducing a regression? A well written set of micro-tests will <em>speed you up</em>. It will not only show you where the problem is with laser pointer precision, but it will describe the regression to you ‚Äî telling you what's broken and what effect it would have on the business and end users. Thus giving you all the information you need to fix it, without the need for a debugger. Assuming, obviously, that you've given your test names the attention they deserve.</p><h1>Typing vs thinking, quality at speed</h1><p>The idea that writing tests first (which is a part of TDD, but not all of it) slows you down comes from two misconceptions: "typing as a bottleneck" and "quality as a force opposing speed". Both are wrong.</p><p>I'm not sure who said that, but if typing was the bottleneck, then typists (or Starcraft players) would've replaced programmers. In programming, you only have to type well and fast enough that thoughts don't slip your mind before you put them in writing. The thoughts are what's important. As Kevlin Henney puts it, "you should remember to bring your brain to the keyboard".</p><p>Regarding quality vs speed, Allen Holub wrote that <a href="https://twitter.com/allenholub/status/1354530936063365120">if you trade one for the other, you will end up with neither</a>. Speed without quality is just a great way to crash and burn. Ask race drivers. So if you sacrifice quality for speed, it won't be sustainable.</p><p>Sacrificing speed for quality, on the other hand, is illusory. At least since Deming we know that <strong>quality can only be achieved by building it into the process</strong>, working in small iterations, and getting rid of¬†<a href="https://en.wikipedia.org/wiki/Muda_(Japanese_term)">waste</a>. That makes sustainable speed an inevitable consequence of quality.</p><p>In other words, <strong>if you don't get a sustainable speed from your quality assurance process, it‚Äôs not giving you quality either. If you don't support your speed with quality, you're going to hit a wall.</strong></p><h1>The learning curve</h1><p>All that said, TDD¬†<em>will</em>¬†slow you down at first, especially assuming you're used to writing imperatively ‚Äî starting from IFs and FORs. That's just how it works. For most people, there's a number of mental shifts that need to happen before it becomes natural. Certainly was the case for me.</p><p><strong>The bad news is, it's not just a matter of practice</strong>. A great teacher, Eddie Woo, said that "<a href="https://www.youtube.com/watch?v=ylJd5sUbANE">practice does not make perfect, practice makes habits</a>" and this is what I see from many people attempting TDD. They jump into it without theory and deeper thought, ending up causing "test induced damage" to their code. The aforementioned mental shifts don't happen automatically, and unless you're blessed with a brain of Kent Beck, they require the right fuel to trigger them.</p><h1>The resources</h1><p>For me (as you may imagine if you've read any of my other posts here or my Twitter) one of the most helpful things was the <strong>study of feedback-based approaches to quality by design</strong>. There are a couple of great points of entry for that, coming from the IT angle. The best is probably the book <a href="https://www.amazon.com/Phoenix-Project-DevOps-Helping-Business/dp/0988262592">"The Phoenix Project" by Gene Kim</a>, which is actually a novel, so it's insanely easy to read.</p><p>It isn't <em>really</em> about TDD and that's kind of the point. It's a rabbit hole exposing you to the world of Lean, the Toyota Production System, PDSA, and Deming. Will it¬†<em>directly</em>¬†contribute to your understanding of TDD? No. Will it help you switch your brain to prepare it understand TDD, continuous delivery, DevOps, and agile in general, through the lens of feedback? Absolutely.</p><p>The other extremely useful resource is <strong>Kevlin Henney</strong>. And I'm deliberately not pointing you to anything specific from him, because you just can't go wrong by simply typing that name into Google or YouTube. <strong>Kevlin's role in making me a better programmer, especially by helping me bend my brain backwards to get a grip on TDD, cannot be overstated</strong>. Kevlin also has the power to instil in you a healthy dose of interest in linguistics, which is kind of helpful if your daily work involves a (programming, but nevertheless) language.</p><p>The last but not least, grab <a href="https://www.amazon.com/Test-Driven-Development-Kent-Beck/dp/0321146530">Test Driven Development</a> and <a href="https://www.amazon.com/Smalltalk-Best-Practice-Patterns-Kent/dp/013476904X">Smalltalk </a>by Kent Beck.</p><h1>Conclusion</h1><p>It's not always a simple path, depending on where you start, and it's easy to get tricked into thinking that "writing tests first" is all there is to TDD. But after years of writing almost exclusively with TDD I can attest that the only way it slows you down is the¬†<em>good</em>¬†way - by giving you time to wind down and think of the code you're writing.</p></div><footer class="post__inner post__footer"><div class="post__share-tag-container"><div class="post__share"><button class="post__share-button js-post__share-button icon" aria-label="Share button"><i class="fas fa-share-alt"></i></button><div class="post__share-popup js-post__share-popup"><a href="https://twitter.com/share?url=%23PUBLII_RELATIVE_URL_BASE%23%2Fcontinuous-quality-assurance-through-tdd%2F&amp;via=peter_podgorski&amp;text=Continuous%20quality%20assurance%20through%20TDD" class="js-share icon brands fa-twitter" rel="nofollow noopener noreferrer"><span class="label">Twitter</span> </a><a href="https://www.linkedin.com/sharing/share-offsite/?url=%23PUBLII_RELATIVE_URL_BASE%23%2Fcontinuous-quality-assurance-through-tdd%2F" class="js-share icon brands fa-linkedin" rel="nofollow noopener noreferrer"><span class="label">LinkedIn</span></a></div></div></div></footer></article><div><strong>You should also read:</strong></div><div class="posts"><article><header><time datetime="2020-11-01T22:02" class="date">01/11/2020</time><h2><a href="./../pdsa/">The Cycle of Continuous Improvement</a></h2></header><p></p><ul class="actions special"><li><a href="./../pdsa/" class="button">Full Story</a></li></ul></article></div></main><footer id="copyright"><p>‚ÄúWhen you program, you have to think about how someone will read your code, not just how a computer will interpret it.‚Äù<br>‚Äî Kent Beck</p></footer></div><script src="./../assets/js/jquery.min.js?v=7c14a783dfeb3d238ccd3edd840d82ee"></script><script src="./../assets/js/jquery.scrollex.min.js?v=f89065e3d988006af9791b44561d7c90"></script><script src="./../assets/js/jquery.scrolly.min.js?v=1ed5a78bde1476875a40f6b9ff44fc14"></script><script src="./../assets/js/browser.min.js?v=c07298dd19048a8a69ad97e754dfe8d0"></script><script src="./../assets/js/breakpoints.min.js?v=81a479eb099e3b187613943b085923b8"></script><script src="./../assets/js/util.min.js?v=4201a626f8c9b614a663b3a1d7d82615"></script><script src="./../assets/js/main.min.js?v=149e72e3ae18744a477b480b19e0c6da"></script></body></html>