<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><title>Code, language, communication - Peter Podgorski</title><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="./../code-language-communication/"><style>:root{--primary-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--secondary-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"}</style><link rel="stylesheet" href="./../assets/css/fontawesome-all.min.css?v=dbf9d822cefe851ba6f66e1ad57e8987"><link rel="stylesheet" href="./../assets/css/style.css?v=d7345ee9a5567d776f15f161bddf38f7"><noscript><link rel="stylesheet" href="./../assets/css/noscript.css?v=6228c7eee614cd200a2cad8333b439fa"></noscript><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"./../code-language-communication/"},"headline":"Code, language, communication","datePublished":"2020-11-11T22:22","dateModified":"2022-03-11T23:42","description":"","author":{"@type":"Person","name":"Peter Podgorski"},"publisher":{"@type":"Organization","name":"Peter Podgorski"}}</script><style>#wrapper > .bg {
               background-image: url(./../assets/images/overlay.png), linear-gradient(0deg, rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.1)), url(./../media/website/oip-221-3.jpg);
           }</style></head><body class="is-preload"><div id="wrapper"><header id="header"><a class="logo" href="./../">Peter Podgorski</a></header><nav id="nav"><ul class="links"><li><a href="./../" target="_self">Blog</a></li><li><a href="./../more-about-me-2/" target="_self">About</a></li><li><a href="./../tags/foundations/" target="_self">Foundations</a></li></ul><ul class="icons"><li><a href="https://twitter.com/peter_podgorski" class="icon brands fa-twitter"><span class="label">Twitter</span></a></li><li><a href="https://www.instagram.com/peter.podgorski/" class="icon brands fa-instagram"><span class="label">Instagram</span></a></li><li><a href="https://www.linkedin.com/in/piotrpodgórski/" class="icon brands fa-linkedin"><span class="label">LinkedIn</span></a></li></ul></nav><main id="main"><article class="post"><header class="major"><time datetime="2020-11-11T22:22" class="date">11/11/2020</time><h1>Code, language, communication</h1><p class="post__inner"></p></header><div class="post__inner post__entry"><p>Funny how the world works at times. Not long after writing about <a href="./../writing-code-is-design/">programming being design</a> (note that things don’t necessarily land here right after I write them, at least for now) I found a <a href="https://twitter.com/jfarrellism/status/1315349944426024965">tweet</a> asking why we even bother ourselves with bridge or house building analogies and metaphors, instead of taking programming for what it is — programming? It made me think about this more, so I want to share why I consider it both valuable and inevitable.</p><h4>Analogies are inevitable</h4><p>Our brains are wired in such a way that they look for similarities and try really hard to categorize the world around us. Sometimes they get it wrong and since we can't escape this process, I think it's worthwhile to try and make it more informed. Especially when it’s a part of a <a href="./../pdsa/">feedback loop</a> influencing our perception of programming, which is definitely the case for me.</p><p>I think the best examples of how categorization affects perception and unlocks the areas of creativity you need to recognize and solve the problems in front of you, are to be found in the history of some of the largest businesses of our time. You see, in order to be good at the stuff you do, you first need to understand what business you're in.</p><p>I already talked about <a href="./../writing-code-is-design/">McDonald’s and their burger business</a>, but you may not be aware that McDonald’s is not actually a fast food company. They’re a real estate company. Realizing this marked the difference between building an international empire and filing for bankruptcy for the guy who created the franchise (who, by the way, wasn’t a McDonald). Sure, the burgers are important, but when you look at the big picture of the whole franchise, they're only important because they allow the <em>buildings</em> to make money. It’s upside down.</p><p>Another similar example is Amazon. Seemingly a store but the problems they faced in the first years of operation were solved by taking clues from FedEx or UPS, not Walmart. They were distribution problems, not retail problems. Same with Facebook. To the average person it’s a social network, aka a place to communicate with your friends, express your interests, and share cat memes. But everyone at Facebook understands that they are an advertisement company and the whole app is just an insanely addictive, interactive billboard. And then we have Apple, which looks like a software and hardware company, but is really an amalgamation of a fashion designer with a church (it’s ok, I can say that, I'm writing this on a Mac). On the other hand, looking at these companies taxes, maybe they all are... But I digress.</p><p>The point is, had these companies failed to correctly identify the core business they’re in — be it real estate, warehousing and delivery, or advertisements — they would've found their problems impossible to solve, because they would've been trying to solve them in a wrong framework.</p><p>Your perception of the nature of your work affects how you do that work. Which is why it’s so important to think of programming as design, and of software production as that immediate, cheap, negligible process of program execution.</p><h4>Who do we write code for?</h4><p>The detrimental side effect of seeing programming as "producing software" is that you see the code and the (running) application as two facets of a single end product. But that leaves one of these facets without a target audience, because while the end users are certainly interested in working software, they couldn’t care less for the code itself.</p><p>Thus the value of the code is diminished and it's seen as an almost unfortunate byproduct of the process. I've even heard both programmers and executives say things like: "clients don’t care about code quality, they care if it works". And I pushed back against that idea directly, until I realized the misconception lies somewhere else. It’s just that we <em>do not</em> write code for clients, customers, or users. We write it for each other. And yes, I’m not pretending to be original in this idea, just to provide my view on it.</p><p>Again, it’s the same as a technical drawing. It’s kind of useless for the home owners or investors. Heck, they might not even be able to fully understand it, even if the visual nature of it makes it arguably easier than with code. What they’re interested in is a house that doesn’t collapse on itself. The target audiences for the design are architects and contractors. In the same way, if we decouple code (as the design) from the final software (as the product) we’ll be able to find the target audience for the code: other programmers. This is perfectly summed up by Kevlin Henney's idea of programming as "<strong>codifying knowledge</strong>" as well as by this quote from Harold Abelson's "Structure and Interpretation of Computer Programs":</p><blockquote><p>Programs must be written for people to read, and only incidentally for machines to execute.</p></blockquote><p>So what are the qualities other programmers will look for in a piece of code, if we view it as a design document? From the top of my head I’d list explicitness, descriptiveness, and clarity. First and foremost, that design has to be understandable and unambiguous to them. And it must make it clear what the end product is supposed to be, just like it’s obvious from a technical drawing that the structure it describes is a barn, a house, or a car.</p><p>The difference is that while technical drawings are a visual medium, code is a textual one. And while it can be visualized with stuff like C4 or UML, the important part to remember is that these are <em>not</em> the final design. They’re accompanying documents. Helpers, if you will. They’re not used by the builder (the computer) to realize the end product (stuff of screen), which is why they’re not the source of truth — the code is. That’s also why Simon Brown insists on encoding enough information in your code to be able to automatically generate meaningful visualizations, rather than drawing them. Otherwise they will simply drift apart and become a source of confusion.</p><h4>The purpose of software</h4><p>Ok, but there’s one more quality of software which we haven’t talked about yet, but which is extremely important here. The clue is in the name — <strong>soft</strong>ware. As opposed to hardware, software should be moldable and easy to change. After all, that’s the idea behind having a programmable computer: not having to rebuild the physical structure every time we want to do something else. The very idea of software came from the realization that <em>what </em>we need from computers changes more often than <em>how</em> they make it happen. Which leads us to the conclusion that the purpose of software is to change.</p><p>And this is the most important quality other programmers will, whether they realize it or not, look for in the code you write — ease of change. Because that’s what they’ll be asked to do: make that code do something else.</p><p>And that's always to root of it, regardless whether they're adding a new feature or fixing a defect. After all, there's no reason to even look at the design (be it code or technical drawings) unless you want to modify the structure. Which brings us all the way back to that quote about <a href="./../the-debt-metaphor/">technical debt</a>:</p><blockquote><p>You’re wise to make that software reflect your understanding as best you can, so that when it comes time to refactor it’s clear what you were thinking when you wrote it.</p></blockquote><p>Conversely, it’s unwise to write software in a sloppy way, which obscures that initial understanding instead of exposing it. It would be like an architect creating a technical drawing which looks like doodle. If another architect was tasked with adjusting the structure, they would say it’s easier to tear it down, as they have no idea where the wet walls are or how the electrical installation is made. Does that ring a bell?</p><p>Interestingly, even relatively well structured codebases usually have at least one place like that — the Master Function which does everything and everyone working on the project knows that as soon as there’s a need to modify it, they’ll just need to rewrite the whole thing. It's not because it doesn’t do what it’s supposed to be doing <em>right now</em>. The structure as it stands is perfectly legit. It’s just that nobody understands the design document.</p><p>How can we avoid this? How can we write code which is understandable and unambiguous to our peers? It all starts with understanding what that code is — a piece of design we create not only to meet the immediate needs of our customers, but also the future needs of the developers (be it ourselves or our successors). And that the code, being a design document, is first and foremost a one way communication device between us today and them in the future.</p></div><footer class="post__inner post__footer"><div class="post__share-tag-container"><div class="post__tag"><h3>Tagged in:</h3><ul><li><a href="./../tags/foundations/">Foundations</a></li></ul></div><div class="post__share"><button class="post__share-button js-post__share-button icon" aria-label="Share button"><i class="fas fa-share-alt"></i></button><div class="post__share-popup js-post__share-popup"><a href="https://twitter.com/share?url=%23PUBLII_RELATIVE_URL_BASE%23%2Fcode-language-communication%2F&amp;via=peter_podgorski&amp;text=Code%2C%20language%2C%20communication" class="js-share icon brands fa-twitter" rel="nofollow noopener noreferrer"><span class="label">Twitter</span> </a><a href="https://www.linkedin.com/sharing/share-offsite/?url=%23PUBLII_RELATIVE_URL_BASE%23%2Fcode-language-communication%2F" class="js-share icon brands fa-linkedin" rel="nofollow noopener noreferrer"><span class="label">LinkedIn</span></a></div></div></div></footer></article></main><footer id="copyright"><p>“When you program, you have to think about how someone will read your code, not just how a computer will interpret it.”<br>— Kent Beck</p></footer></div><script src="./../assets/js/jquery.min.js?v=7c14a783dfeb3d238ccd3edd840d82ee"></script><script src="./../assets/js/jquery.scrollex.min.js?v=f89065e3d988006af9791b44561d7c90"></script><script src="./../assets/js/jquery.scrolly.min.js?v=1ed5a78bde1476875a40f6b9ff44fc14"></script><script src="./../assets/js/browser.min.js?v=c07298dd19048a8a69ad97e754dfe8d0"></script><script src="./../assets/js/breakpoints.min.js?v=81a479eb099e3b187613943b085923b8"></script><script src="./../assets/js/util.min.js?v=4201a626f8c9b614a663b3a1d7d82615"></script><script src="./../assets/js/main.min.js?v=149e72e3ae18744a477b480b19e0c6da"></script></body></html>